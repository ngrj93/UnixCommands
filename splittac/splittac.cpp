//@ Nagaraj Poti - 20162010 

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<errno.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<sys/mman.h>
#include<assert.h>
#include<fcntl.h>
#include<unistd.h>
#include<cstring>
#include<dirent.h>

#define MAX_PATH 4097
#define NOT_ENOUGH_ARG 2
#define TOO_MANY_ARG 3
#define INV_INT_ARG 4
#define INV_SOURCE 5
#define WRITE_ERROR 6
#define MAXLEN 1000000

using namespace std;

class SplitTac{

private:

	char **args;  //command line arguments 
	int arg_count;  //number of command line arguments 
	int num_lines;  //number of lines in each file
	struct dirent **namelist;  //storage of file/dir names generated by scandir()
	int source_file_count;  //number of source files in source directory

public:

	SplitTac(){  //default constructor
		args=NULL;
		namelist=NULL;
		num_lines=source_file_count=arg_count=0;
	}

//-----------------------------------------------------
	void handle_error(int errsv){   //error handling function
		cerr<<"Error: ";
		if(errsv==NOT_ENOUGH_ARG)
			cerr<<"Missing operands --help split [source] [destination] [#lines]"<<endl;
		else if(errsv==TOO_MANY_ARG)
			cerr<<"Extra operand(s)"<<endl;
		else if(errsv==INV_INT_ARG)
			cerr<<"Invalid integer value"<<endl;
		else if(errsv==INV_SOURCE)
			cerr<<"No such file or directory"<<endl;
		else if(errsv==WRITE_ERROR)
			cerr<<"File write error"<<endl;
		_exit(-1);
	}

//-----------------------------------------------------
	void handle_file_error(int errsv){   //error handling related to file specific issues 
		cerr<<"Error: ";
		if(errsv==EACCES)
			cerr<<"Permission denied"<<endl;
		else
			cerr<<"Error"<<endl;
	}

//-----------------------------------------------------
	void open_input_dir(){			//verify validity of the input directory
		source_file_count=scandir(args[0],&namelist,NULL,alphasort);  //populate namelist with file names
		if(source_file_count<0)
			handle_error(INV_SOURCE);
	}

//-----------------------------------------------------
	void fix_output_dir(){             //to remove generated swap files
		struct dirent **output_namelist;
		int n=scandir(args[1],&output_namelist,NULL,alphasort);
		while(n--){
			char path[MAX_PATH]={0};
			strcat(path,args[1]);
			strcat(path,output_namelist[n]->d_name);
			if(is_file(path) && strchr(output_namelist[n]->d_name,'~'))
				unlink(path);
			free(output_namelist[n]);
		}
		free(output_namelist);
	}
//-----------------------------------------------------
	void open_output_dir(){     //recursively create directory if it does not exist
		int size=strlen(args[1]);
		for(int i=0;i<size;i++){
			if(args[1][i]=='/'){
				args[1][i]='\0';
				mkdir(args[1],S_IRWXU);
				args[1][i]='/';
			}
		}
	}

//-----------------------------------------------------
	int is_file(char *path){		//check whether the path points to a file or directory
		struct stat p;
		stat(path, &p);
		return S_ISREG(p.st_mode);
	}

//-----------------------------------------------------
	void reverse_lines(int ofd,int tfd){     //reverse the split files 
		struct stat p;
		fstat(tfd,&p);
		char *mp,*ptr;
		mp=(char*)mmap(0,p.st_size,PROT_READ,MAP_PRIVATE,tfd,0);    //mapping file to memory
		assert(mp!=MAP_FAILED);	
		ptr=mp+p.st_size-1;
		char buffer[MAXLEN]={0};
		while(ptr>=mp){
			int i=0;
			do{
				buffer[i++]=*ptr;
				ptr--;
			}while(ptr>=mp && *ptr!='\n');
			int b_size=strlen(buffer)-1;
			for(int i=0;i<b_size/2;i++){
				char c=buffer[i];				//reverse buffer
				buffer[i]=buffer[b_size-i];
				buffer[b_size-i]=c;
			}
			write(ofd,buffer,strlen(buffer));
			memset(buffer,0,sizeof(buffer));
		}
		munmap(mp,p.st_size);
	}

//-----------------------------------------------------
	void split_tac(char *filepath,char *filename){    //split-tac
		ssize_t n;
		char buffer[MAXLEN],path[MAX_PATH],temp_file_path[MAX_PATH];
		int input_fd=open(filepath,O_RDONLY),line_count=0,output_fd,file_counter=1,output_temp_fd;
		if(input_fd==-1){
			int errsv=errno;
			handle_file_error(errsv);
			return;
		}
		sprintf(path,"%s%s_%d",args[1],filename,file_counter);
		sprintf(temp_file_path,"%s%s",args[1],".temp");
		output_fd=open(path,O_CREAT|O_WRONLY|O_TRUNC,S_IRWXU);
		output_temp_fd=open(temp_file_path,O_CREAT|O_RDWR|O_TRUNC,S_IRWXU);
		if(output_fd==-1){
			int errsv=errno;
			handle_file_error(errsv);
		}
		while((n=read(input_fd,buffer,MAXLEN))>0){
			char temp[MAXLEN]={0};
			int b_size=0;
			for(int i=0;i<n;i++){
				if(line_count==num_lines){
					reverse_lines(output_fd,output_temp_fd);
					close(output_fd);
					close(output_temp_fd);
					line_count=0;
					memset(path,0,sizeof(path));
					sprintf(path,"%s%s_%d",args[1],filename,++file_counter);
					output_fd=open(path,O_CREAT|O_WRONLY|O_TRUNC,S_IRWXU);
					output_temp_fd=open(temp_file_path,O_CREAT|O_RDWR|O_TRUNC,S_IRWXU);
				}
				if(buffer[i]=='\n'){
					temp[b_size++]='\n';
					if(write(output_temp_fd,temp,b_size)<0)
						handle_error(WRITE_ERROR);
					memset(temp,0,sizeof(temp));
					b_size=0;
					line_count++;
				}
				else
					temp[b_size++]=buffer[i];
			}
		}
		if(line_count>0)
			reverse_lines(output_fd,output_temp_fd);
		close(input_fd);
		close(output_fd);
		close(output_temp_fd);
	}

//-----------------------------------------------------
	void perform_action(){     //function to iterate through files and perform split-tac
		int n=source_file_count;
		while(n--){
			char path[MAX_PATH]={0};
			strcat(path,args[0]);
			strcat(path,namelist[n]->d_name);
			if(is_file(path))
				split_tac(path,namelist[n]->d_name);
			free(namelist[n]);
		}
		free(namelist);
	}

//-----------------------------------------------------
	void discern_semantics(){  //factory method
		open_input_dir();
		open_output_dir();
		perform_action();
	}

//-----------------------------------------------------
	void parse(int c,char **a){
		if(c<4)
			handle_error(NOT_ENOUGH_ARG);  
		else if(c>4)
			handle_error(TOO_MANY_ARG);
		else if(atoi(a[3])==0)
			handle_error(INV_INT_ARG);
		args=new char*[2];
		num_lines=atoi(a[3]);
		arg_count=2;
		for(int i=1;i<=arg_count;i++){          //copying command line arguments to class member args
			args[i-1]=new char[MAX_PATH];
			strcpy(args[i-1],a[i]);
			if(args[i-1][strlen(args[i-1])-1]!='/'){   //appending '/' to end of the path if required
				args[i-1][strlen(args[i-1])]='/';
				args[i-1][strlen(args[i-1])+1]='\0';
			}
		}
		discern_semantics();
	}

//-----------------------------------------------------
	~SplitTac(){                 //destructor call 
		for(int i=0;i<2;i++)
			delete(args[i]);
		delete(args);
	}
};

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int main(int argc,char **argv){							//main() function
	SplitTac sp;  //make new application object for split-tac 
	sp.parse(argc,argv); 
	sp.fix_output_dir(); 
	return 0;
}
